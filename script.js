javascript // Create the scene, camera, and renderer const scene = new THREE.Scene(); const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true }); // Set up the camera and renderer camera.position.z = 5; renderer.setSize(window.innerWidth, window.innerHeight); // Create a cube and add it to the scene const geometry = new THREE.BoxGeometry(1, 1, 1); const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); const cube = new THREE.Mesh(geometry, material); scene.add(cube); // Create a torus and add it to the scene const torusGeometry = new THREE.TorusGeometry(1, 0.5, 16, 60); const torusMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); const torus = new THREE.Mesh(torusGeometry, torusMaterial); scene.add(torus); // Create a sphere and add it to the scene const sphereGeometry = new THREE.SphereGeometry(1, 32, 32); const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial); scene.add(sphere); // Create a particle system const particleGeometry = new THREE.BufferGeometry(); const particleMaterial = new THREE.PointsMaterial({ color: 0xffffff }); const particleSystem = new THREE.Points(particleGeometry, particleMaterial); scene.add(particleSystem); // Initialize the particle system const particleCount = 1000; const particlePositions = new Float32Array(particleCount * 3); for (let i = 0; i < particleCount; i++) { const x = Math.random() * 2 - 1; const y = Math.random() * 2 - 1; const z = Math.random() * 2 - 1; particlePositions[i * 3] = x; particlePositions[i * 3 + 1] = y; particlePositions[i * 3 + 2] = z; } particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3)); // Add some epic visuals const epicVisuals = []; for (let i = 0; i < 10; i++) { const visualGeometry = new THREE.TorusGeometry(0.5, 0.2, 16, 60); const visualMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff }); const visual = new THREE.Mesh(visualGeometry, visualMaterial); visual.position.x = Math.random() * 2 - 1; visual.position.y = Math.random() * 2 - 1; visual.position.z = Math.random() * 2 - 1; epicVisuals.push(visual); scene.add(visual); } // Animate the scene function animate() { requestAnimationFrame(animate); cube.rotation.x += 0.01; cube.rotation.y += 0.01; torus.rotation.x += 0.02; torus.rotation.y += 0.02; sphere.rotation.x += 0.03; sphere.rotation.y += 0.03; particleSystem.rotation.x += 0.01; particleSystem.rotation.y += 0.01; epicVisuals.forEach((visual) => { visual.rotation.x += 0.01; visual.rotation.y += 0.01; }); renderer.render(scene, camera); } animate();
